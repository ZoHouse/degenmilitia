import{P as e,h as n}from"./paths-B891YjWw.mjs";import{arbitrumSepolia as r,arbitrum as t,avalancheFuji as a,avalanche as i,baseSepolia as o,base as l,polygonAmoy as s,polygon as d,optimismSepolia as c,optimism as u,sepolia as f,mainnet as p}from"@privy-io/js-sdk-core";import{useCallback as E,useContext as h}from"react";import{a as m,h as g,e as y,u as w,P as C}from"./privy-context-DDSW3jEM.mjs";import{d1 as v,d2 as D,aS as T,an as b,aA as S,as as W,c2 as A,aa as U}from"./SignRequestScreen-cNZ56bAg.mjs";import{u as x}from"./internal-context-CfE_S5P-.mjs";function M(e){return["ethereum","solana"].includes(e.chainType)}function _(e){let n=e.replace("eip155:","");if(n)return parseInt(n);throw Error("Chain ID not compatible with CAIP-2 format.")}const P=e=>e.filter((e=>"wallets"===e.method||("exchange"===e.method?"coinbase"===e.provider:"card"===e.method||"payment-request"===e.method?"coinbase"===e.provider||"moonpay"===e.provider:(e.method,!1)))),R={[p.id]:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",[f.id]:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",[u.id]:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",[c.id]:"0x5fd84259d66Cd46123540766Be93DFE6D43130D7",[d.id]:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",[s.id]:"0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",[l.id]:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",[o.id]:"0x036CbD53842c5426634e7929541eC2318f3dCF7e",[i.id]:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",[a.id]:"0x5425890298aed601595a70ab815c96711a31bc65",[t.id]:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",[r.id]:"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"},F=({address:n,appConfig:r,fundWalletConfig:t,methodScreen:a,chainIdOverride:i,comingFromSendTransactionScreen:o=!1})=>{let l,s;if(!r.fundingConfig)throw Error("Wallet funding is not enabled");let d=P(r.fundingConfig.options);if(d.length<1)throw Error("Wallet funding is not enabled");l=i||(t?.chain?t.chain.id:_(r.fundingConfig.defaultRecommendedCurrency.chain));let c=r.chains.find((e=>e.id===l));if(!c)throw new e(`Funding chain ${l} is not in PrivyProvider chains list`);let u=t?.amount??r.fundingConfig.defaultRecommendedAmount,f=!1;function p(){if(!l)return;let e=R[l];d.find((e=>"wallets"===e.method))&&!e&&console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."),s=e,f=!0}var E;t&&"asset"in t?"USDC"===t.asset?p():"string"!=typeof t.asset&&"erc20"in t.asset&&(E=s=t.asset.erc20,f=E===R[c.id]):"USDC"===r.fundingConfig.defaultRecommendedCurrency.asset&&p();let h=t?.defaultFundingMethod;return{chainType:"ethereum",address:n,amount:u,chain:c,erc20Address:s,erc20ContractInfo:f?{symbol:"USDC",decimals:6}:void 0,isUSDC:f,methodScreen:a,supportedOptions:d,comingFromSendTransactionScreen:o,defaultFundingMethod:h,usingDefaultFundingMethod:!!h,preferredCardProvider:t?.card?.preferredProvider,crossChainBridgingEnabled:r.fundingConfig.crossChainBridgingEnabled??!1,solanaChain:"solana:mainnet",uiConfig:t&&"uiConfig"in t?t.uiConfig:void 0,externalSolanaFundingScreen:null}};function I({address:e,fundWalletConfig:n,appConfig:r,comingFromSendTransactionScreen:t,externalSolanaFundingScreen:a,methodScreen:i}){if(!r.fundingConfig)throw Error("Wallet funding is not enabled");let o=P(r.fundingConfig.options);if(o.length<1)throw Error("Wallet funding is not enabled");if("USDC"===n?.asset&&"solana:testnet"===n?.chain)throw Error("USDC funding is not supported on the Solana testnet");let l=n?.amount??r.fundingConfig.defaultRecommendedAmount,s=n?.defaultFundingMethod;return{chainType:"solana",address:e,supportedOptions:o,amount:l,isUSDC:"USDC"===n?.asset,methodScreen:i,comingFromSendTransactionScreen:t,chain:n?.chain||"solana:mainnet",crossChainBridgingEnabled:r.fundingConfig.crossChainBridgingEnabled??!1,defaultFundingMethod:s,preferredCardProvider:n?.card?.preferredProvider,usingDefaultFundingMethod:!!s,uiConfig:n?.uiConfig,externalSolanaFundingScreen:a}}const B=e=>e.reduce(((e,n)=>!e||e.walletIndex<n.walletIndex?n:e),null),O=async({appConfig:e,getAccessToken:r,initializeWalletProxy:t,user:a,privy:i,emitPrivyEvent:o,recoverEmbeddedWallet:l,setModalData:s,openModal:d,setUser:c,options:u,timeoutDuration:f,refreshSessionAndUser:p,chainType:E})=>{let[h,m]=await Promise.all([t(f),r()]);if(!m||!a)throw o("createWallet","onError",n.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");if(!h&&e.customAuth?.enabled)throw o("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(u&&"walletIndex"in u&&"number"==typeof u.walletIndex){if("user-controlled-server-wallets-only"===e.embeddedWallets.mode)throw o("createWallet","onError",n.INVALID_DATA),Error("Invalid input, use `createAdditional` instead of `walletIndex` to create additional wallets.");return k({accessToken:m,appConfig:e,privy:i,emitPrivyEvent:o,openModal:d,proxy:h,refreshSessionAndUser:p,recoverEmbeddedWallet:l,setModalData:s,user:a,walletIndex:u.walletIndex,chainType:E,setUser:c})}let g=u&&"createAdditional"in u&&u.createAdditional,y=v(a,{chainType:E});if(y[0]&&!g)throw o("createWallet","onError",n.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");return k({accessToken:m,appConfig:e,privy:i,emitPrivyEvent:o,openModal:d,proxy:h,recoverEmbeddedWallet:l,setModalData:s,user:a,walletIndex:(B(y)?.walletIndex??-1)+1,chainType:E,refreshSessionAndUser:p,setUser:c})};let k=async({accessToken:e,appConfig:r,privy:t,emitPrivyEvent:a,proxy:i,refreshSessionAndUser:o,recoverEmbeddedWallet:l,user:s,walletIndex:d,setModalData:c,openModal:u,chainType:f,setUser:p})=>{if(d<0)throw a("createWallet","onError",n.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${d}) is invalid.`);let E=m(s);if(d>0&&!E)throw a("createWallet","onError",n.EMBEDDED_WALLET_NOT_FOUND),Error("Must have an existing embedded wallet to create an additional wallet.");if(r.embeddedWallets.requireUserOwnedRecoveryOnCreate&&"user-controlled-server-wallets-only"===r.embeddedWallets.mode)throw a("createWallet","onError",n.EMBEDDED_WALLET_CREATE_ERROR),Error("User owned recovery not yet supported for this app.");if(!E&&r.embeddedWallets.requireUserOwnedRecoveryOnCreate)return await L({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});let h=v(s,{chainType:f,walletIndex:d})[0];if(h)return{user:s,account:h};if(0===d&&!i)return L({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});if(!i)throw a("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return D({appConfig:r,walletIndex:d,chainType:f,user:s,accessToken:e,proxy:i,refreshSessionAndUser:o,privy:t,recoverEmbeddedWallet:l,setUser:p})},L=async({emitPrivyEvent:e,setModalData:r,openModal:t,chainType:a})=>new Promise(((i,o)=>{r({createWallet:{onSuccess:({user:n,account:r})=>{e("createWallet","onSuccess",{wallet:r}),i({user:n,account:r})},onFailure:r=>{e("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),o(r)},callAuthOnSuccessOnClose:!1,shouldCreateEth:"ethereum"===a,shouldCreateSol:"solana"===a}}),t(T)}));const N=()=>{let e=b(),r=S(),{setModalData:t}=W(),{initializeWalletProxy:a,recoverEmbeddedWallet:i,setUser:o,openModal:l,refreshSessionAndUser:s,privy:d,client:c}=x();return{create:async({chainType:u,options:f,latestUser:p})=>{let E=p;if(E||(E=await s()),!E)throw r("createWallet","onError",n.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return await O({appConfig:e,privy:d,getAccessToken:()=>c.getAccessToken(),refreshSessionAndUser:s,initializeWalletProxy:a,user:E,emitPrivyEvent:r,recoverEmbeddedWallet:i,setModalData:t,openModal:l,setUser:o,options:f,timeoutDuration:A,chainType:u})}}};function K(e){let{create:n}=N();return U("createWallet",e),{createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let{account:r}=await n({chainType:"ethereum",options:e});return r}}}const z=async({emitPrivyEvent:r,getAccessToken:t,initializeWalletProxy:a,refreshSessionAndUser:i,user:o,appConfig:l},{privateKey:s,chainType:d,additionalSigners:c})=>{if(!o)throw r("linkAccount","onError",n.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");let u="user-controlled-server-wallets-only"===l.embeddedWallets.mode?"tee":"on-device";if(c&&"on-device"===u)throw new e("Specifying additionalSigners is only supported for TEE execution and this app uses On-device execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let[f,p]=await Promise.all([t(),a(15e3)]);if(!p||!f)throw r("linkAccount","onError",n.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");let{address:E}=await p.importWallet({privateKey:s,accessToken:f,chainType:d,mode:u,additionalSigners:c}),h=await i(),m="solana"===d?g(h):y(h),w=m?.find((e=>e.address===E));if(!w)throw r("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to import wallet");return r("createWallet","onSuccess",{wallet:w}),w},j=()=>{let{user:e}=w(),{client:n,refreshSessionAndUser:r,initializeWalletProxy:t}=x(),a=S(),i=b();return{importWallet:E((({privateKey:o,additionalSigners:l})=>z({getAccessToken:()=>n.getAccessToken(),user:e,initializeWalletProxy:t,refreshSessionAndUser:r,emitPrivyEvent:a,appConfig:i},{privateKey:o,chainType:"ethereum",additionalSigners:l})),[e,n,r,t,a,i])}},q=()=>{let{importWallet:e}=j(),{createWallet:n}=K();return{...h(C),importWallet:e,createWallet:n}};export{N as a,K as b,j as c,z as d,_ as e,P as f,I as g,M as i,F as p,q as u};
